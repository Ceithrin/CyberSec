

n = "0x7CD1020889B4382BE84B3F14EAAE242755CC1BD56F431B348F4FF8F207A96F41AFCF3EBDF4C17CB6537AD4B01B9FF9497763B22D013B614C8FCDB0C34F9D88F1A523013791EDFEB1FBBA160799892C118892FB7F199C9957DF5A26DAB4D776E5226F06ACD05412F6DD2B1B75D24CE9DC2DDAC513BCB96CD9B97F9BEF8543A3A1"

phi = "0x7CD1020889B4382BE84B3F14EAAE242755CC1BD56F431B348F4FF8F207A96F41AFCF3EBDF4C17CB6537AD4B01B9FF9497763B22D013B614C8FCDB0C34F9D88F037D2317D3864035ECE8BCDD458711B788B5B3FDFD5164F7D736D0A56F416E8C16126E3868D73F54AF4D61F6033E069994319C849460C60A725A0F4DD97EDCC84"

e = "0x10001"

print(int(phi, 16))
print()

print(int(n, 16))
print()

ciphertext = "0x268D7D5F5593EA30F536635B58585620B51D2D143AFE4734635C259278D61413D0C89678E81EDF466B1E45E27EBF802F62F61263E499A516465163C7CB668F94258B3424C3E2BD76634923DECD670E4B6034F8FD00C76F9DAD00A72DB22B70B9408C89FCEE4C9B0D2D4B5664284328711BFAD57FBE1EDCC0854AAD57390DCAD6"


print(int(ciphertext, 16))


d = 49752560166993717130394987818429730823759806218942766444956481273933473576608547793601894682530196952846244721061139495286080305150591429508331413765889316689418218959910941707748141437726995862472357237087587948038825023101993206743009522621721010946811763191087913044077894858267689957329009699192115788229

plaintext = pow(int(ciphertext, 16), d, int(n, 16))

print()
print(plaintext)

# def integer_to_bytes(integer, _bytes):
#     output = bytearray()
#     for byte in range(_bytes):        
#         output.append((integer >> (8 * (_bytes - 1 - byte))) & 255)
#     return output


# print(integer_to_bytes(plaintext, 255))

# ## Funkcje pomocnicze 
# def gcd(a, b):
#     # GCD - Greatest Common Divisor, Największy wspólny dzielnik 
#     while a != 0:
#         a, b = b % a, a
#     return b

# # wersja rekurencyjna
# def gcdExtendedRecursion(a, b):  
#     # przypadek trywialny
#     if a == 0 :   
#         return b,1,0             
#     gcd,x1,y1 = gcdExtendedRecursion(b%a, a) #rekurencyjny Euklides      
   
#     # sumowanie powrotne  
#     y = x1 - (b//a) * y1  
#     x = y1  
    
#     return gcd,x,y 

# #wersja iteracyjna
# def findModInverse(a, m):
#     # Zwraca liczbę x odwrotną do a ciele skończonym modulo m 
#     # czyli (a*x) % m =1 

#     if gcd(a, m) != 1:
#         return None #a i m muszą być względnie pierwsze aby istniał element odwrotny 

#     # Rozszerzony algorytm Euklidesa 
#     u1, u2, u3 = 1, 0, a
#     v1, v2, v3 = 0, 1, m
#     while v3 != 0:
#         q = u3 // v3 # // operator dzielenie całkowitoliczbowego 
#         v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
#     return u1 % m


# a, b = 65537,87649082972615446885156213990388141958462041885187282183358321369043253078954716183685582963065012168992348062798954305060720006415266001335650005751863878602037628450194440652151553598137526621296494079379835255789373284025572667141114891644303376103362880682087270696210666254302024051328494090372669885572
# g, x, y = gcdExtendedRecursion(a, b)  
# # print("gcd(", a , "," , b, ") = ", g, x, y)
# print("Element odwrotny do ", a, "modulo", b, ":", y%b)
# print()
# print(findModInverse(65537,87649082972615446885156213990388141958462041885187282183358321369043253078954716183685582963065012168992348062798954305060720006415266001335650005751863878602037628450194440652151553598137526621296494079379835255789373284025572667141114891644303376103362880682087270696210666254302024051328494090372669885572))